-- 03_functions.sql
-- Generated by SQL Schema Splitter
-- Contains 16 statements
-- Source: prod-declarative-301225.sql







CREATE OR REPLACE FUNCTION "public"."badge_unseen_counts"("p_user" "uuid") RETURNS TABLE("pending_count" bigint, "match_count" bigint)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
  WITH
  -- 1. Unseen pending requests
  unseen_incoming AS (
    SELECT actor_user AS liker_user
    FROM public.interactions
    WHERE target_user = p_user
      AND action = 'like'
      AND timestamp_seen_by_target IS NULL
  ),
  my_likes AS (
    SELECT target_user AS liked_user
    FROM public.interactions
    WHERE actor_user = p_user
      AND action = 'like'
  ),
  blocked_pairs AS (
    SELECT
      least(actor_user, target_user) AS u_min,
      greatest(actor_user, target_user) AS u_max
    FROM public.interactions
    WHERE action = 'blocked'
  ),
  active_matches AS (
    SELECT
      least(user_a, user_b) AS u_min,
      greatest(user_a, user_b) AS u_max
    FROM public.matches
    WHERE active
  ),
  pending_filtered AS (
    SELECT ui.liker_user
    FROM unseen_incoming ui
    LEFT JOIN my_likes ml ON ml.liked_user = ui.liker_user
    LEFT JOIN blocked_pairs bp
      ON bp.u_min = least(p_user, ui.liker_user)
     AND bp.u_max = greatest(p_user, ui.liker_user)
    LEFT JOIN active_matches am
      ON am.u_min = least(p_user, ui.liker_user)
     AND am.u_max = greatest(p_user, ui.liker_user)
    WHERE ml.liked_user IS NULL  -- I haven't liked them back
      AND bp.u_min IS NULL        -- Not blocked
      AND am.u_min IS NULL        -- Not already an active match
  ),
  
  -- 2. Unseen novel matches
  unseen_mutual_likes AS (
    SELECT actor_user AS other_user
    FROM public.interactions
    WHERE target_user = p_user
      AND action = 'like'
      AND timestamp_seen_by_target IS NULL
    
    INTERSECT
    
    SELECT target_user AS other_user
    FROM public.interactions
    WHERE actor_user = p_user
      AND action = 'like'
  ),
  matches_filtered AS (
    SELECT uml.other_user
    FROM unseen_mutual_likes uml
    LEFT JOIN blocked_pairs bp
      ON bp.u_min = least(p_user, uml.other_user)
     AND bp.u_max = greatest(p_user, uml.other_user)
    LEFT JOIN active_matches am
      ON am.u_min = least(p_user, uml.other_user)
     AND am.u_max = greatest(p_user, uml.other_user)
    WHERE bp.u_min IS NULL  -- Not blocked
      AND am.u_min IS NULL  -- Not already an active match
  )
  
  SELECT
    (SELECT count(*)::bigint FROM pending_filtered) AS pending_count,
    (SELECT count(*)::bigint FROM matches_filtered) AS match_count
$$;


ALTER FUNCTION "public"."badge_unseen_counts"("p_user" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."banner_counts"("p_user" "uuid", "p_idea_id" "text" DEFAULT NULL::"text", "p_model" "text" DEFAULT NULL::"text", "p_version" "text" DEFAULT NULL::"text") RETURNS TABLE("loc_count" bigint, "sim_count" bigint)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
  with
  -- viewer profile + settings
  viewer_info as (
    select
      p.user_id,
      p.city_id,
      us.region_scope,
      case coalesce(us.similarity_threshold, 0)
        when 1 then -0.80  -- Highly Similar
        when 2 then -0.65  -- Similar
        when 3 then -0.55  -- Broadly Similar
        when 4 then -0.45  -- Vaguely Similar
        else null
      end as sim_floor
    from public.profiles p
    left join public.user_settings us on us.user_id = p.user_id
    where p.user_id = p_user
    limit 1
  ),
  v_city as (
    select
      vi.user_id,
      vi.city_id,
      vi.region_scope,
      vi.sim_floor,
      c.id              as v_city_id,
      c.country_iso2    as v_country,
      c.m49_region   as v_region
    from viewer_info vi
    left join public.cities c on c.id = vi.city_id
  ),
  -- candidates that pass the VIEWER -> CANDIDATE location filter
  cand_pool as (
    select
      pr.user_id as cand_user_id,
      pr.city_id as c_city_id,
      ci.country_iso2  as c_country,
      ci.m49_region as c_region
    from public.profiles pr
    left join public.cities ci on ci.id = pr.city_id
    cross join v_city vc
    where
      pr.is_published is true                    -- optional, if you have this flag
      and pr.user_id <> vc.user_id            -- exclude self
      -- location filter: only if viewer has scope + viewer city set
      and (
        vc.region_scope is null
        or vc.city_id is null
        or case vc.region_scope
             when 'city'      then pr.city_id     = vc.v_city_id
             when 'country'   then ci.country_iso2 = vc.v_country
             when 'region' then ci.m49_region = vc.v_region
             else true
           end
      )
      -- exclude blocked pairs
      and not exists (
        select 1
        from public.interactions bi
        where bi.action = 'blocked'
          and least(bi.actor_user,  bi.target_user)  = least(vc.user_id, pr.user_id)
          and greatest(bi.actor_user, bi.target_user) = greatest(vc.user_id, pr.user_id)
      )
  ),
  loc_count_cte as (
    select count(distinct cand_user_id)::bigint as loc_count from cand_pool
  ),
  -- similarity count (optional: only if we have an anchor idea + floor)
  q as (
    select emb.semantic_vector_ev2
    from public.embeddings emb
    where p_idea_id is not null
      and p_model   is not null
      and p_version is not null
      and emb.entity_type = 'idea'
      and emb.entity_id   = p_idea_id
      and emb.model       = p_model
      and emb.version     = p_version
    limit 1
  ),
  sim_users as (
    -- any candidate whose ANY idea meets the similarity floor (cosine)
    select distinct cp.cand_user_id
    from cand_pool cp
    join v_city vc on true
    join q on true
    join public.user_ventures uv on uv.user_id = cp.cand_user_id
    join public.embeddings e
      on e.entity_type = 'idea'
     and e.entity_id   = uv.id::text
     and e.model       = p_model
     and e.version     = p_version
    where
      -- cosine similarity (pgvector <#>) ∈ [-1,1]; compare directly to floor
      (vc.sim_floor is null or (e.semantic_vector_ev2 <#> q.semantic_vector_ev2) <= vc.sim_floor)
  ),
  sim_count_cte as (
    select
      case when (select count(*) from q) = 0 then 0::bigint
           else (select count(*)::bigint from sim_users)
      end as sim_count
  )
  select
    (select loc_count from loc_count_cte) as loc_count,
    (select sim_count from sim_count_cte) as sim_count;
$$;


ALTER FUNCTION "public"."banner_counts"("p_user" "uuid", "p_idea_id" "text", "p_model" "text", "p_version" "text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."block_user"("p_actor" "uuid", "p_target" "uuid") RETURNS "void"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
begin
  insert into public.interactions (actor_user, target_user, action)
  select p_actor, p_target, 'block'
  where not exists (
    select 1 from public.interactions bi
    where bi.action = 'block'
      and least(bi.actor_user, bi.target_user)   = least(p_actor, p_target)
      and greatest(bi.actor_user, bi.target_user)= greatest(p_actor, p_target)
  );
end $$;


ALTER FUNCTION "public"."block_user"("p_actor" "uuid", "p_target" "uuid") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."cities_norm_trg"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
begin
  new.name_norm   := unaccent(lower(new.name));
  new.admin1_norm := unaccent(lower(coalesce(new.admin1, '')));
  return new;
end $$;


ALTER FUNCTION "public"."cities_norm_trg"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."f_unaccent"("text") RETURNS "text"
    LANGUAGE "sql" IMMUTABLE PARALLEL SAFE
    AS $_$
  select unaccent('public.unaccent'::regdictionary, $1)
$_$;


ALTER FUNCTION "public"."f_unaccent"("text") OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."knn_candidates_interact_prefs_applied_hnsw"("p_idea_id" "text", "p_model" "text", "p_version" "text", "p_limit" integer DEFAULT 200, "p_search_depth" integer DEFAULT 40, "p_pass_cooldown_days" integer DEFAULT 60) RETURNS TABLE("entity_id" "text", "user_id" "uuid", "title" "text", "description" "text", "idea_sim" double precision)
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
begin
  perform set_config('hnsw.ef_search', p_search_depth::text, true);

  return query
  with
  -- owner of the anchor idea
  viewer as (
    select uv.user_id
    from public.user_ventures uv
    where uv.id::text = p_idea_id
    limit 1
  ),
  -- viewer profile + settings (similarity threshold + region scope)
  viewer_info as (
    select
      v.user_id,
      p.city_id,
      us.region_scope,
      case coalesce(us.similarity_threshold, 0)
        when 1 then -0.80
        when 2 then -0.65
        when 3 then -0.55
        when 4 then -0.45
        else null
      end as sim_floor
    from viewer v
    left join public.profiles p on p.user_id = v.user_id
    left join public.user_settings us on us.user_id = v.user_id
  ),
  -- viewer city attributes
  v_city as (
    select
      vi.user_id,
      vi.region_scope,
      vi.city_id,
      vi.sim_floor,
      vc.id            as v_city_id,
      vc.country_iso2  as v_country,
      vc.m49_region as v_region
    from viewer_info vi
    left join public.cities vc on vc.id = vi.city_id
  ),
  -- anchor vector
  q as (
    select emb.semantic_vector_ev2
    from public.embeddings emb
    where emb.entity_type = 'idea'
      and emb.entity_id  = p_idea_id
      and emb.model      = p_model
      and emb.version    = p_version
    limit 1
  ),
  -- raw kNN candidates
  base as (
    select
      e.entity_id,
      uv.user_id,
      uv.title,
      uv.description,
      (e.semantic_vector_ev2 <#> q.semantic_vector_ev2)               as cosine_similarity,
      100*((e.semantic_vector_ev2 <#> q.semantic_vector_ev2)*(-1) + 1)/2   as idea_sim
    from public.embeddings e
    cross join q
    join public.user_ventures uv on uv.id::text = e.entity_id
    where e.entity_type = 'idea'
      and e.entity_id <> p_idea_id
      and e.model   = p_model
      and e.version = p_version
    order by e.semantic_vector_ev2 <#> q.semantic_vector_ev2
    limit p_limit * 4
  ),
  -- candidate location + candidate's region preference
  cand_city as (
    select
      b.*,
      cprof.city_id            as c_city_id,
      cc.country_iso2          as c_country,
      cc.m49_region         as c_region,
      us.region_scope          as cand_region_scope
    from base b
    join public.profiles cprof on cprof.user_id = b.user_id
    left join public.cities cc on cc.id = cprof.city_id
    left join public.user_settings us on us.user_id = b.user_id
  )
  select cc.entity_id, cc.user_id, cc.title, cc.description, cc.idea_sim
  from cand_city cc
  join v_city vc on true
  join viewer v on true
  where
    -- never show yourself
    cc.user_id <> v.user_id
    -- SIMILARITY FLOOR
    and (vc.sim_floor is null or cc.cosine_similarity <= vc.sim_floor)
    -- VIEWER → CANDIDATE region filter (only if viewer has scope + viewer city known)
    and (
      vc.region_scope is null
      or vc.city_id is null
      or case vc.region_scope
           when 'city'      then cc.c_city_id   = vc.v_city_id
           when 'country'   then cc.c_country   = vc.v_country
           when 'region' then cc.c_region = vc.v_region
           else true
         end
    )
    -- CANDIDATE → VIEWER mutual region filter (only if candidate has scope + candidate city known)
    and (
      cc.cand_region_scope is null
      or cc.c_city_id is null
      or case cc.cand_region_scope
           when 'city'      then vc.v_city_id   = cc.c_city_id
           when 'country'   then vc.v_country   = cc.c_country
           when 'region' then vc.v_region = cc.c_region
           else true
         end
    )
    -- EXCLUSIONS
    and not exists (
      select 1
      from public.interactions bi
      where bi.action = 'blocked'
        and least(bi.actor_user, bi.target_user)    = least(v.user_id, cc.user_id)
        and greatest(bi.actor_user, bi.target_user) = greatest(v.user_id, cc.user_id)
    )
    and not exists (
      select 1
      from public.interactions li
      where li.actor_user  = v.user_id
        and li.target_user = cc.user_id
        and li.action = 'like'
    )
    and not exists (
      select 1
      from public.interactions pi
      where pi.actor_user  = v.user_id
        and pi.target_user = cc.user_id
        and pi.action = 'pass'
        and pi.created_at > now() - (p_pass_cooldown_days || ' days')::interval
    )
  order by cc.cosine_similarity
  limit p_limit;
end $$;


ALTER FUNCTION "public"."knn_candidates_interact_prefs_applied_hnsw"("p_idea_id" "text", "p_model" "text", "p_version" "text", "p_limit" integer, "p_search_depth" integer, "p_pass_cooldown_days" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."pending_requests"("p_user" "uuid", "p_limit" integer DEFAULT 50, "p_offset" integer DEFAULT 0) RETURNS TABLE("user_id" "uuid", "liked_at" timestamp with time zone, "name" "text", "city_id" bigint)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
  with incoming as (
    select actor_user as liker_user, max(created_at) as liked_at
    from public.interactions
    where target_user = p_user
      and action = 'like'
    group by actor_user
  ),
  my_like as (
    select target_user as liked_user
    from public.interactions
    where actor_user = p_user
      and action = 'like'
  ),
  blocked_pairs as (
    select
      least(actor_user, target_user)  as u_min,
      greatest(actor_user, target_user) as u_max
    from public.interactions
    where action = 'blocked'
  ),
  active_matches as (
    select
      least(user_a, user_b) as u_min,
      greatest(user_a, user_b) as u_max
    from public.matches
    where active
  )
  select
    i.liker_user as user_id,
    i.liked_at,
    pr.name,
    pr.city_id
  from incoming i
  join public.profiles pr on pr.user_id = i.liker_user
  left join my_like ml
    on ml.liked_user = i.liker_user
  left join blocked_pairs bp
    on bp.u_min = least(p_user, i.liker_user)
   and bp.u_max = greatest(p_user, i.liker_user)
  left join active_matches m
    on m.u_min = least(p_user, i.liker_user)
   and m.u_max = greatest(p_user, i.liker_user)
  where
    ml.liked_user is null
    and bp.u_min is null
    and m.u_min  is null
  order by i.liked_at desc
  limit p_limit offset p_offset
$$;


ALTER FUNCTION "public"."pending_requests"("p_user" "uuid", "p_limit" integer, "p_offset" integer) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."search_cities"("p_q" "text", "p_country_iso2" character DEFAULT NULL::"bpchar", "p_limit" integer DEFAULT 10) RETURNS TABLE("id" bigint, "name" "text", "admin1" "text", "country_name" "text", "country_iso2" character, "lat" double precision, "lon" double precision, "population" integer, "score" real)
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
  with params as (
    select unaccent(lower(trim(p_q))) as q
  )
  select
    c.id, c.name, c.admin1, c.country_name, c.country_iso2,
    c.lat, c.lon, c.population,
    greatest(
      word_similarity(c.name_norm, (select q from params)),
      similarity(      c.name_norm, (select q from params))
    ) as score
  from public.cities c
  where (
      c.name_norm like (select q from params) || '%'
      or similarity(c.name_norm, (select q from params)) > 0.2
    )
    and (p_country_iso2 is null or c.country_iso2 = p_country_iso2)
  order by score desc nulls last, c.population desc nulls last, c.name asc
  limit p_limit;
  $$;


ALTER FUNCTION "public"."search_cities"("p_q" "text", "p_country_iso2" character, "p_limit" integer) OWNER TO "postgres";